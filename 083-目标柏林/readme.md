#目标柏林

##题目描述
　　1945年初，苏军和英美联军已从东西两面攻入德国国境。 4月初，在苏军和英美联军的夹击下，德军只能龟缩在以柏林为中心的德国东部的狭长地带，成了瓮中之鳖。 但希特勒困兽犹斗，一方面发出摧毁一切设施，实行“焦土”政策的指令； 另一方面下令把德国分为南北两个行政区，各自作战，他自己则固守柏林。<br>
　　在这一天，苏军结果一份传自柏林的加密电文。经初步破译，显示希特勒要调集100万兵力， 在柏林周围筑起了三层防卫圈，并集中3300架飞机，1500多辆坦克，1万门火炮和迫击炮，准备死守柏林。 形势很危机，我们需要马上破译所有密码。请你来遍个程序帮忙破译。<br>
　　苏军知道德军用的加密方法是这样的：<br>
　　1.获得一段文字后，求出它的长度(包括空格)len。<br>
　　2.进入加密运算的第1步:把所有下标是1倍数的字符做顺时针旋转。<br>
　　3.进入加密运算的第2步:把所有下标是2倍数的字符做逆时针旋转。<br>
　　4.进入加密运算的第3步:把所有下标是1倍数的字符做顺时针旋转。<br>
　　5.按上面的规则，第奇数步按顺时针旋转，偶数步按逆时针旋转，一直到第len步为止。<br>
　　比如原文是:abcde<br>
　　1.获得长度len = 5<br>
　　2.1的倍数有1、2、3、4、5，所以把这5个字符按顺时针旋转，得到eabcd。<br>
　　3.2的倍数有2、4，所以把这2个字符按逆时针旋转，得到ecbad。<br>
　　4.3的倍数有3，所以把这1个字符按顺时针旋转，得到ecbad。<br>
　　5.4的倍数有4，所以把这1个字符按逆时针旋转，得到ecbad。<br>
　　6.5的倍数有5，所以把这1个字符按顺时针旋转，得到ecbad。<br>
　　最后的结果是ecbad。<br>
　　现在给你加密后的文章，让你还原成原来的文章。<br>

##输入描述:
　　输入一篇加密后的文章，每行为一段。每段不超过1000个字符。<br>
　　输入以文件结束(EOF)为止。


##输出描述:
　　输出解密后的文章。<br>
　　每段一行。

##输入例子:
```
ecbad
```

##输出例子:
```
abcde
```